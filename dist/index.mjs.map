{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import postcss, { Plugin, Declaration, Result } from \"postcss\";\nimport valueParser, {\n  FunctionNode,\n  Node as ValueParserNode,\n} from \"postcss-value-parser\";\n\n/**\n * Interface for plugin options.\n */\ninterface FluidClampOptions {\n  /**\n   * Enable or disable warnings.\n   * @default false\n   */\n  warnings?: boolean;\n\n  /**\n   * Minimum screen width in pixels for fluid calculations.\n   * @default 768\n   */\n  minWidth?: number;\n\n  /**\n   * Maximum screen width in pixels for fluid calculations.\n   * @default 1536\n   */\n  maxWidth?: number;\n\n  /**\n   * Base font size in pixels.\n   * @default 16\n   */\n  baseFontSize?: number;\n}\n\n/**\n * Fluid Clamp Plugin\n * Replaces @fluid(...) with calc(...) in clamp() functions.\n */\nconst fluidClamp = (opts: FluidClampOptions = {}): Plugin => {\n  const options = {\n    warnings: false,\n    minWidth: 768,\n    maxWidth: 1536,\n    baseFontSize: 16,\n    ...opts,\n  };\n\n  return {\n    postcssPlugin: \"fluid-clamp\",\n    Declaration(decl: Declaration, { result }: { result: Result }) {\n      const parsed = valueParser(decl.value);\n      let hasChanges = false;\n\n      parsed.walk((node: ValueParserNode) => {\n        // Only process 'clamp' functions\n        if (node.type !== \"function\" || node.value !== \"clamp\") {\n          return;\n        }\n\n        const clampFunction = node as FunctionNode;\n\n        // Extract clamp arguments, ignoring dividers (commas)\n        const clampArgs = clampFunction.nodes.filter(\n          (child) => child.type !== \"div\"\n        );\n\n        if (clampArgs.length !== 3) {\n          // Not a standard clamp function with 3 arguments\n          return;\n        }\n\n        // Find @fluid(...) in the arguments\n        const fluidArgIndex = clampArgs.findIndex(\n          (arg) => arg.type === \"function\" && arg.value === \"@fluid\"\n        );\n\n        if (fluidArgIndex === -1) {\n          // No @fluid(...) function found in clamp()\n          return;\n        }\n\n        const fluidFunctionNode = clampArgs[fluidArgIndex] as FunctionNode;\n\n        // Parse @fluid(...) arguments\n        const fluidArgs: number[] = [];\n        let hasInvalidArgs = false;\n\n        fluidFunctionNode.nodes.forEach((child: ValueParserNode) => {\n          if (child.type === \"word\") {\n            const num = parseFloat(child.value);\n            if (!isNaN(num) && num.toString() === child.value) {\n              fluidArgs.push(num);\n            } else {\n              hasInvalidArgs = true;\n            }\n          }\n        });\n\n        // Return early if invalid arguments are found\n        if (hasInvalidArgs) {\n          if (options.warnings) {\n            decl.warn(\n              result,\n              `@fluid function contains invalid numerical arguments.`\n            );\n          }\n          return;\n        }\n\n        // Validate argument count\n        if (![0, 2, 3].includes(fluidArgs.length)) {\n          if (options.warnings) {\n            decl.warn(\n              result,\n              `@fluid function requires either 0, 2, or 3 numerical arguments, but received ${fluidArgs.length}.`\n            );\n          }\n          return;\n        }\n\n        // Validate numerical arguments\n        if (\n          (fluidArgs.length === 2 || fluidArgs.length === 3) &&\n          fluidArgs.some((arg) => typeof arg !== \"number\" || isNaN(arg))\n        ) {\n          if (options.warnings) {\n            decl.warn(\n              result,\n              `@fluid function contains invalid numerical arguments.`\n            );\n          }\n          return;\n        }\n\n        // Destructure options for easier access\n        let { minWidth, maxWidth, baseFontSize } = options;\n\n        if (fluidArgs.length === 2) {\n          minWidth = fluidArgs[0];\n          maxWidth = fluidArgs[1];\n        } else if (fluidArgs.length === 3) {\n          minWidth = fluidArgs[0];\n          maxWidth = fluidArgs[1];\n          baseFontSize = fluidArgs[2];\n        }\n\n        // Parse minFontSize and maxFontSize from clamp()\n        const minFontSizeNode = clampArgs[0];\n        const maxFontSizeNode = clampArgs[2];\n\n        const minFontSize = parseSize(minFontSizeNode.value);\n        const maxFontSize = parseSize(maxFontSizeNode.value);\n\n        if (minFontSize === null || maxFontSize === null) {\n          // Cannot parse font sizes, skip processing\n          return;\n        }\n\n        const sizeDifference = maxFontSize - minFontSize;\n        const widthDifference = maxWidth - minWidth;\n\n        if (widthDifference === 0) {\n          // Replace @fluid(...) with baseFontSize px\n          const fluidValue = `${baseFontSize}px`;\n\n          // Replace only the @fluid(...) function node with the fluidValue\n          Object.assign(fluidFunctionNode, {\n            type: \"word\",\n            value: fluidValue,\n            nodes: undefined,\n          });\n\n          if (options.warnings) {\n            decl.warn(\n              result,\n              `minScreen (${minWidth}px) and maxScreen (${maxWidth}px) are equal. Using minSize (${baseFontSize}px).`\n            );\n          }\n\n          hasChanges = true;\n          return;\n        }\n\n        // Calculate slope and intercept\n        const slope = sizeDifference / widthDifference;\n        const intercept = minFontSize - slope * minWidth;\n\n        const slopeVw = parseFloat((slope * 100).toFixed(5)); // e.g., 0.02083 -> 2.08333vw\n        const interceptPx = parseFloat(intercept.toFixed(5)); // e.g., 0px\n\n        const fluidValue = `calc(${interceptPx}px + ${slopeVw}vw)`;\n\n        // Replace only the @fluid(...) function node with the fluidValue\n        Object.assign(fluidFunctionNode, {\n          type: \"word\",\n          value: fluidValue,\n          nodes: undefined,\n        });\n\n        hasChanges = true;\n      });\n\n      if (hasChanges) {\n        decl.value = parsed.toString();\n      }\n    },\n  };\n};\n\n/**\n * Parses a size string and returns its value in pixels.\n * Supports 'px', 'rem', and 'em' units.\n * Assumes 1rem = 16px and 1em = 16px.\n * Returns null if parsing fails or unit is unsupported.\n *\n * @param {string} value - The size string to parse (e.g., '1rem', '16px').\n * @returns {number | null} The size in pixels or null if invalid.\n */\nfunction parseSize(value: string): number | null {\n  const regex = /^([\\d.]+)(px|rem|em)$/;\n  const match = value.trim().match(regex);\n  if (!match) return null;\n\n  const num = parseFloat(match[1]);\n  const unit = match[2];\n\n  switch (unit) {\n    case \"px\":\n      return num;\n    case \"rem\":\n    case \"em\":\n      return num * 16; // Assuming 1rem = 16px and 1em = 16px\n    default:\n      return null;\n  }\n}\n\n// Essential PostCSS properties for plugin identification\nfluidClamp.postcss = true;\nfluidClamp.postcssPlugin = \"fluid-clamp\";\n\n// EJS export for ES6 modules\nexport default fluidClamp;\n"],"mappings":"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","names":["valueParser","fluidClamp","opts","options","__spreadValues","decl","result","parsed","valueParser","hasChanges","node","clampArgs","child","fluidArgIndex","arg","fluidFunctionNode","fluidArgs","hasInvalidArgs","num","minWidth","maxWidth","baseFontSize","minFontSizeNode","maxFontSizeNode","minFontSize","parseSize","maxFontSize","sizeDifference","widthDifference","fluidValue","slope","intercept","slopeVw","value","regex","match","src_default"]}